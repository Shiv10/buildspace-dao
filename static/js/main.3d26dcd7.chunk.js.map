{"version":3,"sources":["App.jsx","index.js"],"names":["sdk","ThirdwebSDK","bundleDropModule","getBundleDropModule","tokenModule","getTokenModule","voteModule","getVoteModule","App","useWeb3","connectWallet","address","error","provider","console","log","useState","hasClaimedNFT","setHasClaimedNFT","signer","getSigner","undefined","isClaiming","setIsClaiming","memberTokenAmounts","setMemberTokenAmounts","memberAddresses","setMemberAddresses","proposals","setProposals","isVoting","setIsVoting","hasVoted","setHasVoted","useEffect","a","getAll","length","proposalId","getAllClaimerAddresses","getAllHolderBalances","amounts","memberList","useMemo","map","tokenAmount","ethers","utils","formatUnits","setProviderOrSigner","balanceOf","balance","gt","UnsupportedChainIdError","className","style","color","onClick","member","str","toString","substring","onSubmit","e","preventDefault","stopPropagation","votes","proposal","voteResult","vote","forEach","document","getElementById","type","checked","getDelegationOf","constants","AddressZero","delegateTo","Promise","all","get","state","execute","index","description","id","name","value","defaultChecked","htmlFor","label","disabled","mintNft","claim","ReactDOM","render","StrictMode","connectors","injected","supportedChainIds"],"mappings":"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","file":"static/js/main.3d26dcd7.chunk.js","sourcesContent":["import { useEffect, useMemo, useState } from \"react\";\r\nimport { UnsupportedChainIdError } from '@web3-react/core'\r\nimport { ThirdwebSDK } from \"@3rdweb/sdk\";\r\nimport { useWeb3 } from \"@3rdweb/hooks\";\r\nimport { ethers } from 'ethers';\r\n\r\nconst sdk = new ThirdwebSDK(\"rinkeby\");\r\n\r\nconst bundleDropModule = sdk.getBundleDropModule(\r\n  '0xec585f1103706a2bdcc7d4be2a62a6d586d5b3e1',\r\n);\r\n\r\nconst tokenModule = sdk.getTokenModule(\r\n  \"0xb7c565C82f30BA6F1A24b155e5D513075b21d358\",\r\n);\r\n\r\nconst voteModule = sdk.getVoteModule(\r\n  '0xE699Ee2a26b1630CdE82d3A0Aaad2322Dc2d2230'\r\n)\r\n\r\nconst App = () => {\r\n\r\n  const { connectWallet, address, error, provider } = useWeb3();\r\n  console.log(`hello address: ${address}`);\r\n\r\n  const [hasClaimedNFT, setHasClaimedNFT] = useState(false);\r\n\r\n  // The signer is required to sign transactions on the blockchain.\r\n  // Without it we can only read data, not write.\r\n  const signer = provider ? provider.getSigner(): undefined;\r\n\r\n  const [isClaiming, setIsClaiming] = useState(false);\r\n  const [memberTokenAmounts, setMemberTokenAmounts] = useState({});\r\n  const [memberAddresses, setMemberAddresses] = useState([]);\r\n\r\n  const [proposals, setProposals] = useState([]);\r\n  const [isVoting, setIsVoting] = useState(false);\r\n  const [hasVoted, setHasVoted] = useState(false);\r\n\r\n  const shortenAddress = (str) => {\r\n    return str.toString().substring(0,6) + \"...\" + str.toString().substring(str.length - 4);\r\n  }\r\n\r\n  useEffect(async () => {\r\n    if (!hasClaimedNFT) {\r\n      return;\r\n    }\r\n    // A simple call to voteModule.getAll() to grab the proposals.\r\n    try {\r\n      const proposals = await voteModule.getAll();\r\n      setProposals(proposals);\r\n      console.log(\"Proposals:\", proposals);\r\n    } catch (error) {\r\n      console.log(\"failed to get proposals\", error);\r\n    }\r\n  }, [hasClaimedNFT]);\r\n\r\n  useEffect(async () => {\r\n    if (!hasClaimedNFT) {\r\n      return;\r\n    }\r\n\r\n    if (!proposals.length) {\r\n      return;\r\n    }\r\n  \r\n    try {\r\n      const hasVoted = await voteModule.hasVoted(proposals[0].proposalId, address);\r\n      setHasVoted(hasVoted);\r\n      if(hasVoted) {\r\n        console.log(\"User has already voted\");\r\n      } else {\r\n        console.log(\"User has not voted yet\");\r\n      }\r\n    } catch (error) {\r\n      console.error(\"Failed to check if wallet has voted\", error);\r\n    }\r\n  }, [hasClaimedNFT, proposals, address]);\r\n\r\n  useEffect(async () => {\r\n    if (!hasClaimedNFT) {\r\n      return;\r\n    }\r\n    \r\n    // Just like we did in the 7-airdrop-token.js file! Grab the users who hold our NFT\r\n    // with tokenId 0.\r\n    try {\r\n      const memberAddresses = await bundleDropModule.getAllClaimerAddresses(\"0\");\r\n      setMemberAddresses(memberAddresses);\r\n      console.log(\"ðŸš€ Members addresses\", memberAddresses);\r\n    } catch (error) {\r\n      console.error(\"failed to get member list\", error);\r\n    }\r\n  }, [hasClaimedNFT]);\r\n\r\n  useEffect(async () => {\r\n    if (!hasClaimedNFT) {\r\n      return;\r\n    }\r\n  \r\n    // Grab all the balances.\r\n    try {\r\n      const amounts = await tokenModule.getAllHolderBalances();\r\n      setMemberTokenAmounts(amounts);\r\n      console.log(\"ðŸ‘œ Amounts\", amounts);\r\n    } catch (error) {\r\n      console.error(\"failed to get token amounts\", error);\r\n    }\r\n  }, [hasClaimedNFT]);\r\n\r\n  const memberList = useMemo(() => {\r\n    return memberAddresses.map((address) => {\r\n      return {\r\n        address,\r\n        tokenAmount: ethers.utils.formatUnits(\r\n          // If the address isn't in memberTokenAmounts, it means they don't\r\n          // hold any of our token.\r\n          memberTokenAmounts[address] || 0,\r\n          18,\r\n        ),\r\n      };\r\n    });\r\n  }, [memberAddresses, memberTokenAmounts]);\r\n\r\n\r\n  useEffect(async () => {\r\n    sdk.setProviderOrSigner(signer);\r\n  },  [signer]);\r\n\r\n  useEffect(async () => {\r\n    // If they don't have an connected wallet, exit!\r\n    if (!address) {\r\n      return;\r\n    }\r\n\r\n    // Check if the user has the NFT by using bundleDropModule.balanceOf\r\n    const balance = await bundleDropModule.balanceOf(address, \"0\");\r\n   \r\n    try {\r\n      // If balance is greater than 0, they have our NFT!\r\n      if(balance.gt(0)) {\r\n          setHasClaimedNFT(true);\r\n          console.log(\"ðŸŒŸ this user has a membership NFT!\");\r\n      } else {\r\n          setHasClaimedNFT(false);\r\n          console.log(\"ðŸ˜­ this user doesn't have a membership NFT.\")\r\n      }\r\n    } catch (error) {\r\n      setHasClaimedNFT(false);\r\n      console.error(\"failed to nft balance\", error);\r\n    }\r\n  }, [address]);\r\n\r\n  if (error instanceof UnsupportedChainIdError ) {\r\n    return (\r\n      <div className=\"unsupported-network\">\r\n        <h2>Please connect to Rinkeby</h2>\r\n        <p>\r\n          This dapp only works on the Rinkeby network, please switch networks\r\n          in your connected wallet.\r\n        </p>\r\n      </div>\r\n    );\r\n  }\r\n\r\n\r\n  if(!address) {\r\n    return (\r\n      <div className=\"landing\">\r\n        <h1 style={{color: \"black\"}}>Welcome to Football Transfers DAO</h1>\r\n        <button onClick={() => connectWallet(\"injected\")} className=\"btn-hero\">\r\n          Connect your wallet\r\n        </button>\r\n      </div>\r\n    )\r\n  }\r\n\r\n  if(hasClaimedNFT) {\r\n    return (\r\n      <div className=\"member-page\">\r\n        <h1 style={{color: \"black\"}}>Transfer DAO member</h1>\r\n        <div>\r\n          <div>\r\n            <h2 style={{color: \"black\"}}>Member List</h2>\r\n            <table className=\"card\">\r\n              <thead>\r\n                <tr>\r\n                  <th>Address</th>\r\n                  <th>Token Amount</th>\r\n                </tr>\r\n              </thead>\r\n              <tbody>\r\n                {memberList.map((member) => {\r\n                  return (\r\n                    <tr key={member.address}>\r\n                      <td>{shortenAddress(member.address)}</td>\r\n                      <td>{member.tokenAmount}</td>\r\n                    </tr>\r\n                  );\r\n                })}\r\n              </tbody>\r\n            </table>\r\n          </div>\r\n          <div>\r\n            <h2 style={{color: \"black\"}}>Active Proposals</h2>\r\n            <form\r\n              onSubmit={async (e) => {\r\n                e.preventDefault();\r\n                e.stopPropagation();\r\n\r\n                //before we do async things, we want to disable the button to prevent double clicks\r\n                setIsVoting(true);\r\n\r\n                // lets get the votes from the form for the values\r\n                const votes = proposals.map((proposal) => {\r\n                  let voteResult = {\r\n                    proposalId: proposal.proposalId,\r\n                    //abstain by default\r\n                    vote: 2,\r\n                  };\r\n                  proposal.votes.forEach((vote) => {\r\n                    const elem = document.getElementById(\r\n                      proposal.proposalId + \"-\" + vote.type\r\n                    );\r\n\r\n                    if (elem.checked) {\r\n                      voteResult.vote = vote.type;\r\n                      return;\r\n                    }\r\n                  });\r\n                  return voteResult;\r\n                });\r\n\r\n                // first we need to make sure the user delegates their token to vote\r\n                try {\r\n                  //we'll check if the wallet still needs to delegate their tokens before they can vote\r\n                  const delegation = await tokenModule.getDelegationOf(address);\r\n                  // if the delegation is the 0x0 address that means they have not delegated their governance tokens yet\r\n                  if (delegation === ethers.constants.AddressZero) {\r\n                    //if they haven't delegated their tokens yet, we'll have them delegate them before voting\r\n                    await tokenModule.delegateTo(address);\r\n                  }\r\n                  // then we need to vote on the proposals\r\n                  try {\r\n                    await Promise.all(\r\n                      votes.map(async (vote) => {\r\n                        // before voting we first need to check whether the proposal is open for voting\r\n                        // we first need to get the latest state of the proposal\r\n                        const proposal = await voteModule.get(vote.proposalId);\r\n                        // then we check if the proposal is open for voting (state === 1 means it is open)\r\n                        if (proposal.state === 1) {\r\n                          // if it is open for voting, we'll vote on it\r\n                          return voteModule.vote(vote.proposalId, vote.vote);\r\n                        }\r\n                        // if the proposal is not open for voting we just return nothing, letting us continue\r\n                        return;\r\n                      })\r\n                    );\r\n                    try {\r\n                      // if any of the propsals are ready to be executed we'll need to execute them\r\n                      // a proposal is ready to be executed if it is in state 4\r\n                      await Promise.all(\r\n                        votes.map(async (vote) => {\r\n                          // we'll first get the latest state of the proposal again, since we may have just voted before\r\n                          const proposal = await voteModule.get(\r\n                            vote.proposalId\r\n                          );\r\n\r\n                          //if the state is in state 4 (meaning that it is ready to be executed), we'll execute the proposal\r\n                          if (proposal.state === 4) {\r\n                            return voteModule.execute(vote.proposalId);\r\n                          }\r\n                        })\r\n                      );\r\n                      // if we get here that means we successfully voted, so let's set the \"hasVoted\" state to true\r\n                      setHasVoted(true);\r\n                      // and log out a success message\r\n                      console.log(\"successfully voted\");\r\n                    } catch (err) {\r\n                      console.error(\"failed to execute votes\", err);\r\n                    }\r\n                  } catch (err) {\r\n                    console.error(\"failed to vote\", err);\r\n                  }\r\n                } catch (err) {\r\n                  console.error(\"failed to delegate tokens\");\r\n                } finally {\r\n                  // in *either* case we need to set the isVoting state to false to enable the button again\r\n                  setIsVoting(false);\r\n                }\r\n              }}\r\n            >\r\n              {proposals.map((proposal, index) => (\r\n                <div key={proposal.proposalId} className=\"card\" >\r\n                  <h5 style={{color: \"black\"}}>{proposal.description}</h5>\r\n                  <div>\r\n                    {proposal.votes.map((vote) => (\r\n                      <div key={vote.type}>\r\n                        <input\r\n                          type=\"radio\"\r\n                          id={proposal.proposalId + \"-\" + vote.type}\r\n                          name={proposal.proposalId}\r\n                          value={vote.type}\r\n                          //default the \"abstain\" vote to chedked\r\n                          defaultChecked={vote.type === 2}\r\n                        />\r\n                        <label htmlFor={proposal.proposalId + \"-\" + vote.type}>\r\n                          {vote.label}\r\n                        </label>\r\n                      </div>\r\n                    ))}\r\n                  </div>\r\n                </div>\r\n              ))}\r\n              <button disabled={isVoting || hasVoted} type=\"submit\">\r\n                {isVoting\r\n                  ? \"Voting...\"\r\n                  : hasVoted\r\n                    ? \"You Already Voted\"\r\n                    : \"Submit Votes\"}\r\n              </button>\r\n              <small style={{color: \"black\"}}>\r\n                This will trigger multiple transactions that you will need to\r\n                sign.\r\n              </small>\r\n            </form>\r\n          </div>\r\n        </div>\r\n      </div>\r\n      \r\n    )\r\n  }\r\n\r\n  const mintNft = async () => {\r\n    setIsClaiming(true);\r\n    try {\r\n      await bundleDropModule.claim(\"0\", 1);\r\n      setHasClaimedNFT(true);\r\n      console.log(`Successfully Minted! Check it out on OpenSea: https://testnets.opensea.io/assets/${bundleDropModule.address}/0`);\r\n    } catch (e) {\r\n      console.log(\"Failed to claim \", error);\r\n    } finally {\r\n      setIsClaiming(false);\r\n    }\r\n  }\r\n\r\n  return (\r\n    <div className=\"mint-nft\">\r\n      <h1>Mint your free DAO membership NFT</h1>\r\n      <button\r\n        disabled={isClaiming}\r\n        onClick = {() => mintNft()}\r\n      >\r\n        {isClaiming ? \"Minting...\": \"Mint your nft (FREE)\"}\r\n      </button>\r\n    </div>\r\n  )\r\n  \r\n};\r\n\r\nexport default App;\r\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport \"./index.css\";\r\nimport App from \"./App.jsx\";\r\nimport { ThirdwebWeb3Provider } from '@3rdweb/hooks'\r\n\r\n//// Include what chains you wanna support.\r\n// 4 = Rinkeby.\r\nconst supportedChainIds = [4];\r\n\r\n// Include what type of wallet you want to support.\r\nconst connectors = {\r\n  injected: {},\r\n};\r\n\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <ThirdwebWeb3Provider\r\n      connectors={connectors}\r\n      supportedChainIds = {supportedChainIds}\r\n    >\r\n      <App />\r\n    </ThirdwebWeb3Provider>\r\n  </React.StrictMode>,\r\n  document.getElementById(\"root\")\r\n);\r\n"],"sourceRoot":""}